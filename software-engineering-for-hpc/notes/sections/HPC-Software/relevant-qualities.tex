\subsection{Relevant Qualities}

For the two categories explained, there are some important characteristics:
\begin{itemize}
    \item For \definition{Compute-intensive applications}:
    \begin{itemize}
        \item \underline{\definition{Correctness}}: the \textbf{software is correct if it satisfies the specifications}, but be careful! Sometimes, modelling reality into a model (using the specifications) isn't the bigger problem. Instead, it is difficult or impossible to show actual correctness concerning reality. For \example{example}, imagine you are building a simulator of a planet lander before you have ever visited it.
        
        \emph{How can you fix this issue?} We can \textbf{check that the software output fulfils the important desired properties} and \textbf{identify and apply a measure of accuracy}.

        
        \item \underline{\definition{Performance}}: it is the \textbf{efficient use of resources}. Again, be careful! Is it a good idea? Is performance improvement always a good idea? Because it is \textbf{not necessarily if}:
        \begin{itemize}
            \item It makes software \textbf{more difficult to read} and \textbf{maintain}
            \item It \textbf{reduces the portability} of software
        \end{itemize}
        
        
        \item \underline{\definition{Portability}}.
        
        
        \item \underline{\definition{Maintainability}}. A system can have this feature if it follows \textbf{three principles}:
        \begin{enumerate}
            \item \definition{Operability}: \textbf{make it easy for the operations team to run the system and keep it running}. There are a number of things that need to be done to achieve this:
            \begin{itemize}
                \item Provide visibility into the runtime behavior and internals of the system, with good monitoring.

                \item Provide good support for automation and integration with standard tools.

                \item Avoidance of dependencies on individual machines (allowing machines to be taken down for maintenance while the system as a whole continues to run uninterrupted).

                \item Provide good documentation and an easy to understand operational model (\dquotes{If I do X, Y will happen}).

                \item Provide good default behavior, but also give administrators the freedom to override defaults when necessary.

                \item Self-healing when appropriate, but also giving administrators manual control over system state when needed.
            \end{itemize}
            
            \item \definition{Simplicity}: \textbf{make it easy for other software engineers to understand the system}. This is necessary because complex systems take more time to understand and increase the cost of maintenance. There are several techniques for doing this:
            \begin{itemize}
                \item Reducing \emph{accidental complexity}.
                
                \item Using abstractions, such as organising the architecture into well-defined components that hide the internal complexity behind a clear and easy-to-use interface; or reusing known solutions.
            \end{itemize}

            \item \definition{Evolvability}: make it easy for engineers to change the system as new requirements emerge. There are a number of things that need to be done to achieve this:
            \begin{itemize}
                \item Organize your development process to cope with evolution.
                
                \item Keep track of how requirements are mapped to your software structure.

                \item Update documentation.

                \item Continue to ensure simplicity and operability.
            \end{itemize}
        \end{enumerate}
    \end{itemize}

    \item For \definition{Data-intensive applications}:
    \begin{itemize}
        \item \underline{\definition{Reliability}}: can be mathematically defined as \textbf{probability of absence of failures for a certain period}. The typical expectations are:
        \begin{itemize}
            \item The application \textbf{performs the expected function}
            \item It can \textbf{tolerate mistakes by users}
            \item It \textbf{prevents unauthorized access} and \textbf{abuse}
        \end{itemize}
        
        
        \item \underline{\definition{Scalability}}: the \textbf{system ability to cope with increased load}. The load unit depends on the product: for web apps can be represented with the number of requests per second; for databases can be the number of read and write operation (or their ratio).
        
        
        \item \underline{\definition{Maintainability}}. Same as above.
    \end{itemize}
\end{itemize}
In the software, there can be some errors, but a software engineer should be able to recognize the type of failure, faults or defects:
\begin{itemize}
    \item A \definition{defect} is an \textbf{imperfection or deficiency in a work product} where that work product does \underline{not meet its requirements or specifications} and needs to be either repaired or replaced.

    \item A \textbf{defect encountered during software execution} is a \definition{fault} (a fault is a subtype of defect, and can be of two types, see below).
    
    \item A \definition{system failure} can be:
    \begin{itemize}
        \item Termination of the ability of a product to perform a required function or its inability to perform within previously specified limits.

        \item An event in which a system or system component does not perform a required function within specified limits.
    \end{itemize}
\end{itemize}
There are some exceptions where systems are \definition{fault-tolerant} or \definition{resilient}. These are systems that can \textbf{cope with faults and prevent faults from occurring}. An \textbf{advantage of fault-tolerance} is that \textbf{reliability is increased}. 

\newpage

\noindent
The \textbf{fault} can be of \textbf{two types}:
\begin{itemize}
    \item \definition{Hardware Faults}.
    \begin{flushleft}
        \textcolor{Red2}{\textbf{\faIcon{exclamation-triangle} Description of the problem}}
    \end{flushleft}
    It is a defect encountered during hardware execution. In a large datacenter these can happen on a daily basis. Different pieces of hardware usually fail independently from each other.
    \begin{flushleft}
        \textcolor{Green3}{\textbf{\faIcon{check} Possible solutions}}
    \end{flushleft}
    The possible solutions are two: \textbf{hardware redundancy} and \textbf{software fault-tolerance techniques}.

    \item \definition{Software Faults}.
    \begin{flushleft}
        \textcolor{Red2}{\textbf{\faIcon{exclamation-triangle} Description of the problem}}
    \end{flushleft}
    They result from \textbf{software development errors}. Can stay dormant for a long time and appear suddenly. They can \textbf{determine failures in multiple components} at the same time.
    \begin{flushleft}
        \textcolor{Green3}{\textbf{\faIcon{check} Possible solutions}}
    \end{flushleft}
    There is no single solution! It is a combination of strategies. So use defensive programming, by testing before release and during operation:
    \begin{itemize}
        \item Reboot the system frequently (rejuvenation)
        \item Continuous monitoring and alerting in case of possible symptoms
        \item Deliberately introduce failures to train the fault tolerance machinery (chaos engineering)
    \end{itemize}
\end{itemize}

\longline

\subsection{Systems Engineering Methods}

There are several systems engineering methodologies required in High Performance Computing:
\begin{itemize}
    \item Modelling the software structure and checking its properties.
    
    \item Performance analysis and improvement.
    
    \item Source code management.
    
    \item Documentation, standards, support to maintainability.
    
    \item Support to scalability.
    
    \item Attention to operability and automation.
\end{itemize}