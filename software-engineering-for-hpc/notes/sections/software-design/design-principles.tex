\subsection{Design principles}

The following is a list of important design principles in software engineering.

\begin{definitionbox}
    \begin{enumerate}
        \item \textbf{Divide et impera} (also called \emph{divide and conquer})
        
        \item \textbf{Keep the level of abstraction as high as possible}

        \item \textbf{Increase cohesion where possible}

        \item \textbf{Reduce coupling where possible}

        \item \textbf{Design for reusability}

        \item \textbf{Reuse existing designs and code}

        \item \textbf{Design for flexibility}

        \item \textbf{Anticipate obsolescence}

        \item \textbf{Design for portability}

        \item \textbf{Design for testability}

        \item \textbf{Design defensively}
    \end{enumerate}
\end{definitionbox}

\begin{flushleft}
    \large
    \textcolor{Red3}{1. \textbf{Divide et impera} (\emph{divide and conquer})}
\end{flushleft}
\definition{Divide and Conquer} is a \textbf{problem-solving strategy} that involves \textbf{breaking down a complex problem into smaller}, more manageable \textbf{parts}, solving each part individually, and then combining the solutions to solve the original problem.

\begin{flushleft}
    \large
    \textcolor{Red3}{2. \textbf{Keep the level of abstraction as high as possible}}
\end{flushleft}
Ensure that your designs allow you to \textbf{hide or defer consideration of details, thus reducing complexity}. A good abstraction is said to provide \emph{\textbf{information hiding}}. Abstractions allow you to understand the essence of a subsystem without having to know unnecessary details.

\begin{flushleft}
    \large
    \textcolor{Red3}{3. \textbf{Increase cohesion where possible}}
\end{flushleft}
In general, a file, module, class or whatever should contain the same logical methods. For example, in the following class we have two functions with two different purposes (error!).
\begin{lstlisting}[language=Java]
Class Utility {
    ComputeAverageScore(Student s[])
    ReduceImage(Image i)
}\end{lstlisting}

\newpage

\begin{flushleft}
    \large
    \textcolor{Red3}{4. \textbf{Reduce coupling where possible}}
\end{flushleft}
\definition{Coupling} is the \textbf{degree of interdependence between software modules}; a measure of how closely connected two routines or modules are; the strength of the relationships between modules. There are different \textbf{types of couplings}:
\begin{itemize}
    \item \definition{Content coupling} is said to occur when \textbf{one module uses the code of another module}, for instance a branch. This violates \emph{information hiding} (2nd design principle).
    
    \item \definition{Communication coupling} is said to occur when one \textbf{module sends too many messages to another module}. The creation of a message can be optimized and the number of messages sent between these two modules can be reduced.

    \item \definition{Control coupling} is one \textbf{module controlling the flow of another}, by passing it information on what to do. For \example{example}, passing a what-to-do flag or the following code:
    \begin{lstlisting}
class b {
    func(flag f) {
        if(f == flag1) do this
        else if(f == flag2) do that
        else...
    }
}\end{lstlisting}
\end{itemize}
Other types can be viewed \href{https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29#Types_of_coupling}{here}.

\begin{flushleft}
    \large
    \textcolor{Red3}{5. \textbf{Design for reusability}}
\end{flushleft}
Design the various aspects of your system so that they can be \textbf{used again in other contexts}. To do this, you need to follow these rules:
\begin{itemize}
    \item Generalize your design as much as possible;
    \item Simplify your design as much as possible;
    \item Follow the preceding all other design principles;
    \item Design your system to be extensible.
\end{itemize}

\begin{flushleft}
    \large
    \textcolor{Red3}{6. \textbf{Reuse existing designs and code}}
\end{flushleft}
\textbf{Design with reuse is complementary to design for reusability}. Take advantage of the investment you or others have made in reusable components. Note: cloning should not be seen as a form of reuse.

\newpage

\begin{flushleft}
    \large
    \textcolor{Red3}{7. \textbf{Design for flexibility}}
\end{flushleft}
Actively \textbf{anticipate changes that a design may have to undergo in the future}, and prepare for them.  To do this, you need to follow these rules:
\begin{itemize}
    \item Reduce coupling and increase cohesion;
    \item Create abstractions;
    \item Use reusable code and make code reusable;
    \item Do not hard-code anything.
\end{itemize}

\begin{flushleft}
    \large
    \textcolor{Red3}{8. \textbf{Anticipate obsolescence}}
\end{flushleft}
\textbf{Plan for changes in the technology or environment so the software will continue to run or can be easily changed}. So do not rush using early releases of technology. If possible:
\begin{itemize}
    \item Avoid using software libraries that are specific to particular environments;
    \item Avoid using undocumented features or little-used features of software libraries;
    \item Avoid using software or special hardware from companies that are less likely to provide long-term support;
    \item Use standard languages and technologies that are supported by multiple vendors.
\end{itemize}

\begin{flushleft}
    \large
    \textcolor{Red3}{9. \textbf{Design for portability}}
\end{flushleft}
Have the \textbf{software run on as many platforms as possible}. Avoid, if possible, the use of facilities that are specific to one particular environment (e.g. a library only available in Microsoft Windows).

\begin{flushleft}
    \large
    \textcolor{Red3}{10. \textbf{Design for testability}}
\end{flushleft}
Take steps to \textbf{make testing easier}. Design a program to automatically test the software:
\begin{itemize}
    \item Ensure that all the functionality of the code can be driven by an external program, bypassing a graphical user interface;
    \item Create proper code to exercise the other methods/functions;
    \item Use unit test automation frameworks.
\end{itemize}

\begin{flushleft}
    \large
    \textcolor{Red3}{11. \textbf{Design defensively}}
\end{flushleft}
Be careful when you trust how others will try to use a component you are designing. Handle all cases where other code might attempt to use your component inappropriately. Check that all of the inputs to your component are valid: the preconditions. Unfortunately, over-zealous defensive design can result in unnecessarily repetitive checking.